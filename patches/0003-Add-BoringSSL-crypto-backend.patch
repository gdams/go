From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Quim Muntal <qmuntaldiaz@microsoft.com>
Date: Wed, 22 Jun 2022 12:16:05 +0000
Subject: [PATCH] Add BoringSSL crypto backend

---
 .../internal/backend/bbig/big_boring.go       |  12 +
 src/crypto/internal/backend/boring_linux.go   | 267 ++++++++++++++++++
 src/crypto/internal/backend/fips140/boring.go |  11 +
 3 files changed, 290 insertions(+)
 create mode 100644 src/crypto/internal/backend/bbig/big_boring.go
 create mode 100644 src/crypto/internal/backend/boring_linux.go
 create mode 100644 src/crypto/internal/backend/fips140/boring.go

diff --git a/src/crypto/internal/backend/bbig/big_boring.go b/src/crypto/internal/backend/bbig/big_boring.go
new file mode 100644
index 00000000000000..0b62cef68546d0
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big_boring.go
@@ -0,0 +1,12 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.boringcrypto
+
+package bbig
+
+import "crypto/internal/boring/bbig"
+
+var Enc = bbig.Enc
+var Dec = bbig.Dec
diff --git a/src/crypto/internal/backend/boring_linux.go b/src/crypto/internal/backend/boring_linux.go
new file mode 100644
index 00000000000000..94bc444f10eb2b
--- /dev/null
+++ b/src/crypto/internal/backend/boring_linux.go
@@ -0,0 +1,267 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.boringcrypto && linux && cgo && (amd64 || arm64) && !android && !msan
+
+// Package boring provides access to BoringCrypto implementation functions.
+// Check the variable Enabled to find out whether BoringCrypto is available.
+// If BoringCrypto is not available, the functions in this package all panic.
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"crypto/internal/boring"
+	"hash"
+)
+
+const Enabled = true
+
+type BigInt = boring.BigInt
+
+const RandReader = boring.RandReader
+
+func SupportsHash(h crypto.Hash) bool {
+	switch h {
+	case crypto.MD5SHA1, crypto.SHA1, crypto.SHA224, crypto.SHA256, crypto.SHA384, crypto.SHA512:
+		return true
+	default:
+		return false
+	}
+}
+
+func NewMD5() hash.Hash        { panic("cryptobackend: not available") }
+func NewSHA1() hash.Hash       { return boring.NewSHA1() }
+func NewSHA224() hash.Hash     { return boring.NewSHA224() }
+func NewSHA256() hash.Hash     { return boring.NewSHA256() }
+func NewSHA384() hash.Hash     { return boring.NewSHA384() }
+func NewSHA512() hash.Hash     { return boring.NewSHA512() }
+func NewSHA512_224() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA512_256() hash.Hash { panic("cryptobackend: not available") }
+
+func MD5(p []byte) (sum [16]byte)        { panic("cryptobackend: not available") }
+func SHA1(p []byte) (sum [20]byte)       { return boring.SHA1(p) }
+func SHA224(p []byte) (sum [28]byte)     { return boring.SHA224(p) }
+func SHA256(p []byte) (sum [32]byte)     { return boring.SHA256(p) }
+func SHA384(p []byte) (sum [48]byte)     { return boring.SHA384(p) }
+func SHA512(p []byte) (sum [64]byte)     { return boring.SHA512(p) }
+func SHA512_224(p []byte) (sum [28]byte) { panic("cryptobackend: not available") }
+func SHA512_256(p []byte) (sum [32]byte) { panic("cryptobackend: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { return boring.NewHMAC(h, key) }
+
+func NewAESCipher(key []byte) (cipher.Block, error)   { return boring.NewAESCipher(key) }
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error)   { return boring.NewGCMTLS(c) }
+func NewGCMTLS13(c cipher.Block) (cipher.AEAD, error) { return boring.NewGCMTLS13(c) }
+
+type PublicKeyECDSA = boring.PublicKeyECDSA
+type PrivateKeyECDSA = boring.PrivateKeyECDSA
+
+func GenerateKeyECDSA(curve string) (X, Y, D boring.BigInt, err error) {
+	return boring.GenerateKeyECDSA(curve)
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D boring.BigInt) (*boring.PrivateKeyECDSA, error) {
+	return boring.NewPrivateKeyECDSA(curve, X, Y, D)
+}
+
+func NewPublicKeyECDSA(curve string, X, Y boring.BigInt) (*boring.PublicKeyECDSA, error) {
+	return boring.NewPublicKeyECDSA(curve, X, Y)
+}
+
+func SignMarshalECDSA(priv *boring.PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	return boring.SignMarshalECDSA(priv, hash)
+}
+
+func VerifyECDSA(pub *boring.PublicKeyECDSA, hash []byte, sig []byte) bool {
+	return boring.VerifyECDSA(pub, hash, sig)
+}
+
+type PublicKeyRSA = boring.PublicKeyRSA
+type PrivateKeyRSA = boring.PrivateKeyRSA
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *boring.PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return boring.DecryptRSAOAEP(h, mgfHash, priv, ciphertext, label)
+}
+
+func DecryptRSAPKCS1(priv *boring.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return boring.DecryptRSAPKCS1(priv, ciphertext)
+}
+
+func DecryptRSANoPadding(priv *boring.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return boring.DecryptRSANoPadding(priv, ciphertext)
+}
+
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *boring.PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return boring.EncryptRSAOAEP(h, mgfHash, pub, msg, label)
+}
+
+func EncryptRSAPKCS1(pub *boring.PublicKeyRSA, msg []byte) ([]byte, error) {
+	return boring.EncryptRSAPKCS1(pub, msg)
+}
+
+func EncryptRSANoPadding(pub *boring.PublicKeyRSA, msg []byte) ([]byte, error) {
+	return boring.EncryptRSANoPadding(pub, msg)
+}
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv boring.BigInt, err error) {
+	return boring.GenerateKeyRSA(bits)
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv boring.BigInt) (*boring.PrivateKeyRSA, error) {
+	return boring.NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv)
+}
+
+func NewPublicKeyRSA(N, E boring.BigInt) (*boring.PublicKeyRSA, error) {
+	return boring.NewPublicKeyRSA(N, E)
+}
+
+func SignRSAPKCS1v15(priv *boring.PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	return boring.SignRSAPKCS1v15(priv, h, hashed)
+}
+
+func SignRSAPSS(priv *boring.PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	return boring.SignRSAPSS(priv, h, hashed, saltLen)
+}
+
+func VerifyRSAPKCS1v15(pub *boring.PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	return boring.VerifyRSAPKCS1v15(pub, h, hashed, sig)
+}
+
+func VerifyRSAPSS(pub *boring.PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	return boring.VerifyRSAPSS(pub, h, hashed, sig, saltLen)
+}
+
+type PublicKeyECDH = boring.PublicKeyECDH
+type PrivateKeyECDH = boring.PrivateKeyECDH
+
+func ECDH(priv *boring.PrivateKeyECDH, pub *boring.PublicKeyECDH) ([]byte, error) {
+	return boring.ECDH(priv, pub)
+}
+
+func GenerateKeyECDH(curve string) (*boring.PrivateKeyECDH, []byte, error) {
+	return boring.GenerateKeyECDH(curve)
+}
+
+func NewPrivateKeyECDH(curve string, bytes []byte) (*boring.PrivateKeyECDH, error) {
+	return boring.NewPrivateKeyECDH(curve, bytes)
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*boring.PublicKeyECDH, error) {
+	return boring.NewPublicKeyECDH(curve, bytes)
+}
+
+func SupportsHKDF() bool { return false }
+
+func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte, keyLength int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsPBKDF2() bool { return false }
+
+func PBKDF2(password, salt []byte, iter, keyLen int, fh func() hash.Hash) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsTLS1PRF() bool { return false }
+
+func TLS1PRF(result, secret, label, seed []byte, h func() hash.Hash) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDESCipher() bool { return false }
+
+func SupportsTripleDESCipher() bool { return false }
+
+func NewDESCipher(key []byte) (cipher.Block, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewTripleDESCipher(key []byte) (cipher.Block, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsRC4() bool { return false }
+
+type RC4Cipher struct{}
+
+func (c *RC4Cipher) Reset()                       { panic("cryptobackend: not available") }
+func (c *RC4Cipher) XORKeyStream(dst, src []byte) { panic("cryptobackend: not available") }
+
+func NewRC4Cipher(key []byte) (*RC4Cipher, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsEd25519() bool { return false }
+
+type PublicKeyEd25519 struct{}
+
+func (k PublicKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+type PrivateKeyEd25519 struct{}
+
+func (k PrivateKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func GenerateKeyEd25519() (PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519(priv []byte) (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyEd25519(pub []byte) (*PublicKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519FromSeed(seed []byte) (PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignEd25519(priv PrivateKeyEd25519, message []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyEd25519(pub PublicKeyEd25519, message, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDSA(l, n int) bool {
+	return false
+}
+
+func GenerateParametersDSA(l, n int) (p, q, g boring.BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+type PrivateKeyDSA struct{}
+type PublicKeyDSA struct{}
+
+func GenerateKeyDSA(p, q, g boring.BigInt) (x, y boring.BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyDSA(p, q, g, x, y boring.BigInt) (*PrivateKeyDSA, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyDSA(p, q, g, y boring.BigInt) (*PublicKeyDSA, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignDSA(priv *PrivateKeyDSA, hash []byte, parseSignature func([]byte) (boring.BigInt, boring.BigInt, error)) (r, s boring.BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyDSA(pub *PublicKeyDSA, hashed []byte, r, s boring.BigInt, encodeSignature func(r, s boring.BigInt) ([]byte, error)) bool {
+	panic("cryptobackend: not available")
+}
diff --git a/src/crypto/internal/backend/fips140/boring.go b/src/crypto/internal/backend/fips140/boring.go
new file mode 100644
index 00000000000000..3b583dc0eb0235
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/boring.go
@@ -0,0 +1,11 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.boringcrypto
+
+package fips140
+
+func systemFIPSMode() bool {
+	return false
+}
